# Lab 2 Analysis Questions

1. **Condition variables**  
   Why are two separate conditions (`cv_not_full`, `cv_not_empty`) used with the same lock? Could one condition work, and what are the trade-offs?
   The conditions are used with the same lock as they work with the same shared state (buffer and its lenght). We have two conditions because we have two different waiting reasons (i.e. condition.wait) and the linked wake signals. One is used to make the producer waits (if the buffer is full) and the other one is used to make the consumer waits (if the buffer is empty). Whether the one condition would work depends on how we define the "work". It can work in a sense that the core process can execute. However, it will lead to busy waiting and a lot of overhead (e.g. CPU usage, context switching, etc.).

2. **wait() loop**  
   Explain why `wait()` must be inside a `while` that rechecks the condition. What can go wrong with an `if` (spurious wakeups, races after notify)?
   The logic can face two edge scenarious if we use the conditional "if". One is the spurious wakup and it refers to a situation in which the thread can wake up for no strong reason (without notify() been invoked). In this situation, if we used the conditional "if" it will proceed to thread's main logic and raise the error or broke the program (and even if the program is monadic it will write the exception in the writer monad and broke the composition). The second situation happens due to threads racing after the condition is satisfied (for example, another thread can change the state before this thread can acquire the resource).

3. **notify() calls**  
   What happens if a producer skips `cv_not_empty.notify()` after adding, or a consumer skips `cv_not_full.notify()` after removing?
   This would break the wakup mechanism. For example, if consumer checks whether the buffer is empty and it returns True, the consumer worker invokes the wait method. Then the producers can put items in the buffer but they do not notify the consumers. In this case, producers can reach the buffer limit and consumers can still be asleep. This will lead to a situation similar to the circular wait (but imposed by lack of awareness). On the other hand, if producers check for empty slots in the buffer and there were none, they invoke the wait method. Then consumers can take the items from the buffer, but if they do not notify the producers than producers can stay asleep. The situation is opposite in the direction but the same in the deadlock nature as the previous one. 

4. **Mutual exclusion**  
   Describe the incorrect behaviours if `with self.lock:` is removed from `put` and `get` (e.g., lost items, duplicates, corrupted counts, out-of-order state).
   I think that in this case we create the critical section in our program and all problems related to the race conditions can pop up. For example, we can get corrupted counts on `len(self.buffer)` which is the main guard condition in our loops logic. In such cases we can have the following situation: let's say the buffer `capacity` is 5 and a producer thread A reads the `len(self.buffer) = 4`. Simultaneously, a producer thread B reads the same state - `len(self.buffer) = 4`. Hence, both thread A and thread B proceed to append items to the buffer. This would leed to `len(self.buffer) = 6` which breaks the condition of the maximum buffer capacity. With `deque(maxlen=capacity)` this would result in the leftmost element been discarded from the buffer. In addition, I can think of a very edge situation - let's say that a consumer thread C checks whether the buffer is empty and it returns True so it invokes the wait method. But almost simultaneously a producer thread D puts the item into the buffer and invokes the notify method. However, the consumer missed it and is asleep. If producer threads do not put any additional items into the buffer, the consumer thread can stay asleep (even though one item is in the buffer). These are just 2 possible problems that can emanate from the lock removal.